
// Un uso que le daremos a las funciones es el de contener partes de c√≥digo
// que queramos ejecutar y posiblemente reutilizar. ('modularizar')
// Ser√≠a conveniente separar los ejercicios de pr√°ctica en distintas funciones por este motivo,
// y para evitar tener mucho c√≥digo comentado.

// para este ejemplo vamos a hacer el llamado a esta funci√≥n desde el evento click de un bot√≥n en el html.


function evaluarParidad() {
    // Esta funci√≥n llama a prompt() para tomar un n√∫mero ingresado por el usuario,
    // luego se eval√∫a si el valor ingresado no es un n√∫mero, si no lo es muestra una alerta.
    const numero = prompt('ingrese un n√∫mero para evaluar su paridad');
    const esPar = (parseInt(numero) % 2) === 0;
    const noValido = numero === null || numero === '' || isNaN(numero);

    if (noValido) { // Esta condici√≥n se cumple si alguno de las 3 operaciones resulta en verdadero.
        alert('no se ingreso un n√∫mero v√°lido');
    }
    else if (esPar) { // Si no se cumple la condici√≥n anterior, usa el valor guardado en esPar para evaluar la condici√≥n.
        alert('el n√∫mero ingresado es par');
    }
    else {
        alert('el n√∫mero ingresado es impar');
    }
}

// declaramos una funci√≥n bucleEvaluarParidad que llamara a su vez a evaluarParidad
function bucleEvaluarParidadDe3() {
    // Esta funci√≥n tiene un bucle que se repetir√° mientras que se cumpla la condici√≥n indicada.
    // Cuando esta no se cumpla, es decir que la condici√≥n resulte en false, saldr√° del bucle.
    let contador = 0;
    while (contador < 3) { // Mientras el contador sea menor a 3, el resultado ser√° true.

        evaluarParidad();

        contador++; // el operador ++ le suma +1 a contador, esto es lo que har√° que el bucle deje de repetirse cuando no se cumpla la condici√≥n.
    }
    console.log('Termin√≥ el bucle');
}

function bucleEvaluarParidad() {
    let aceptar = true;
    while (aceptar) { // Aqu√≠ el bucle se repetir√° mientras el usuario presione Aceptar en la ventana del confirm().
        evaluarParidad();
        aceptar = confirm('¬øDesea otro ingresar un n√∫mero para evaluar?');
    }
}

function validarNumero(promptNum) { // La funci√≥n recibe un valor y devuelve un booleano true/false si el valor es un n√∫mero entero o no.
    const valido = !(promptNum === null || promptNum === '' || isNaN(promptNum)); // Esta condici√≥n se cumple si alguna de las 3 operaciones resulta en verdadero. Y luego el resultado es negado o invertido.
    // const valido = promptNum !== null && promptNum !== '' && !isNaN(promptNum); // Esta condici√≥n se cumple si el resultado de todas las operaciones es verdadero.
    return valido;
}


/*Se realiza la carga de 10 valores enteros por teclado. Se desea conocer:
    a)	La cantidad de valores negativos ingresados. ‚úÖ
    b)	La cantidad de valores positivos ingresados. ‚úÖ
    c)	La cantidad de m√∫ltiplos de 15. ‚úÖ
    d)	El valor acumulado de los n√∫meros ingresados que son pares. ‚úÖ*/


/*
Entradas: 10 n√∫meros ingresados por el usuario.

Salidas:
    De esos 10 n√∫meros, mostrar la cantidad de
        negativos
        positivos
        m√∫ltiplos de 15
    y la suma de todos los n√∫meros pares.

Procesos:
    Repetir 10 entradas de datos: BUCLE FOR ()
    Por cada entrada evaluar y contar: CONDICIONALES IF () Y VARIABLES CONTADOR
        si es negativo: OPERACI√ìN L√ìGICA DE RELACI√ìN O RANGO
        si es positivo  
        si es m√∫ltiplo de 15  OPERACI√ìN DE RELACI√ìN Y COMPARACI√ìN 
    Y sumar cada vez que sea par.  OPERACI√ìN DE RELACI√ìN, COMPARACI√ìN Y VARIABLE ACUMULADOR
*/

function evaluar10Numeros() {
    // Para resolver este problema necesitaremos de varios contadores porque se requiere registrar distintas cantidades.
    let cantidadDeNegativos = 0;
    let cantidadDePositivos = 0;
    let cantidadDeMultiplosDe15 = 0;
    let acumuladorDePares = 0; // Y de un acumulador porque es necesario calcular una suma dentro del bucle.

    for (let contador = 0; contador < 10; contador++) { // Usamos un bucle for () para pedir 10 n√∫meros al usuario y evaluar cada uno.
        const numeroEntero = parseInt(prompt('Ingrese un numero entero')); // Guardamos en una constante el n√∫mero ingresado ya parseado/convertido a entero.
        const esNegativo = numeroEntero < 0;
        const esMultiploDe15 = numeroEntero % 15 === 0;

        if (esNegativo) {
            cantidadDeNegativos = cantidadDeNegativos + 1; // Le sumamos +1 al contador de Negativos si se cumple que numeroEntero es negativo.
        } else {
            cantidadDePositivos = cantidadDePositivos + 1; // +1 a la al contador de positivos si no es negativo.
        }
        if (esMultiploDe15) {
            cantidadDeMultiplosDe15 += 1; // +1 al contador de m√∫ltiplos si se cumple la condici√≥n.
        }
        if (numeroEntero % 2 === 0) {
            acumuladorDePares += numeroEntero; // Sumamos el n√∫mero ingresado al acumulador si se cumple que el n√∫mero ingresado es par.
        }
    }

    // Al finalizar la ejecuci√≥n del bucle, mostramos los valores que guardan las variables.
    console.log('La cantidad de negativos es: üòé' + cantidadDeNegativos)
    console.log('La cantidad de positivos es: üòí' + cantidadDePositivos)
    console.log('La cantidad de m√∫ltiplo de 15 es: ü§û' + cantidadDeMultiplosDe15)
    console.log('La suma de los n√∫meros pares es: üòú' + acumuladorDePares)
}



// const array = ['uno', 'dos', 'tres']

// for (let indice = 0; indice < array.length; indice++) {
//     const numero = array[indice];
//     console.log(numero)
// }
